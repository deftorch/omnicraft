//! Rust Code Generator
//!
//! Generates Rust code from the AST.

use crate::ast::*;
use anyhow::Result;
use std::fmt::Write;
use tracing::{instrument, debug};

/// Code generator that produces Rust code from OmniCraft AST
pub struct RustGenerator {
    output: String,
    indent: usize,
}

impl RustGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
        }
    }

    /// Generate Rust code from a component
    #[instrument(skip(self), fields(component = %component.name))]
    pub fn generate(&mut self, component: &Component) -> Result<String> {
        debug!("Generating Rust code for component");
        self.output.clear();

        // Generate module header
        self.emit_header(component)?;

        // Generate component struct
        self.emit_component_struct(component)?;

        // Generate component impl
        self.emit_component_impl(component)?;

        Ok(self.output.clone())
    }

    fn emit_header(&mut self, component: &Component) -> Result<()> {
        writeln!(
            self.output,
            "//! Generated by OmniCraft Compiler"
        )?;
        writeln!(self.output, "//! Source: {}", component.metadata.file_path)?;
        writeln!(self.output, "//! Do not edit manually.")?;
        writeln!(self.output)?;
        writeln!(self.output, "#![allow(unused)]")?;
        writeln!(self.output)?;
        writeln!(self.output, "use omnicraft_runtime::prelude::*;")?;
        writeln!(self.output, "use wasm_bindgen::prelude::*;")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_component_struct(&mut self, component: &Component) -> Result<()> {
        let struct_name = format!("{}Component", self.to_pascal_case(&component.name));

        writeln!(self.output, "/// {}", component.name)?;
        writeln!(self.output, "#[wasm_bindgen]")?;
        writeln!(self.output, "pub struct {} {{", struct_name)?;
        self.indent += 1;

        // Add signal fields from script
        if let Some(script) = &component.script {
            for stmt in &script.statements {
                if let Statement::VariableDeclaration {
                    name,
                    reactive,
                    init,
                    ..
                } = stmt
                {
                    if *reactive != ReactiveKind::None {
                        let ty = self.infer_type(init.as_ref());
                        self.emit_line(&format!(
                            "pub {}: Signal<{}>,",
                            name, ty
                        ))?;
                    }
                }
            }
        }

        self.indent -= 1;
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_component_impl(&mut self, component: &Component) -> Result<()> {
        let struct_name = format!("{}Component", self.to_pascal_case(&component.name));

        // impl OmniComponent trait
        writeln!(self.output, "impl OmniComponent for {} {{", struct_name)?;
        self.indent += 1;

        // fn create()
        self.emit_create_fn(component)?;

        // fn mount()
        self.emit_mount_fn(component)?;

        self.indent -= 1;
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;

        // impl new() for convenience
        self.emit_new_fn(component, &struct_name)?;

        // WASM entry point
        self.emit_wasm_entry_point(component, &struct_name)?;

        Ok(())
    }

    fn emit_create_fn(&mut self, component: &Component) -> Result<()> {
        self.emit_line("fn create(ctx: &mut Context) -> Self {")?;
        self.indent += 1;

        self.emit_line("Self {")?;
        self.indent += 1;

        // Initialize signals
        if let Some(script) = &component.script {
            for stmt in &script.statements {
                if let Statement::VariableDeclaration {
                    name,
                    reactive,
                    init,
                    ..
                } = stmt
                {
                    if *reactive == ReactiveKind::Signal {
                        if let Some(init_expr) = init {
                            let init_val = self.expr_to_rust(init_expr);
                            // Extract inner value from signal() call
                            let inner_val = if let Expression::Call { args, .. } = init_expr {
                                if let Some(arg) = args.first() {
                                    self.expr_to_rust(arg)
                                } else {
                                    "Default::default()".to_string()
                                }
                            } else {
                                init_val
                            };
                            self.emit_line(&format!(
                                "{}: ctx.create_signal({}),",
                                name, inner_val
                            ))?;
                        }
                    }
                }
            }
        }

        self.indent -= 1;
        self.emit_line("}")?;

        self.indent -= 1;
        self.emit_line("}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_mount_fn(&mut self, component: &Component) -> Result<()> {
        self.emit_line("fn mount(&self, world: &mut World) {")?;
        self.indent += 1;

        // Setup canvas
        if let Some(width) = &component.template.canvas.width {
            let w = self.expr_to_rust(width);
            self.emit_line(&format!("world.set_canvas_width({});", w))?;
        }
        if let Some(height) = &component.template.canvas.height {
            let h = self.expr_to_rust(height);
            self.emit_line(&format!("world.set_canvas_height({});", h))?;
        }
        writeln!(self.output)?;

        // Create entities for each element
        for (i, node) in component.template.children.iter().enumerate() {
            self.emit_node(node, i)?;
        }

        self.indent -= 1;
        self.emit_line("}")?;
        Ok(())
    }

    fn emit_node(&mut self, node: &Node, index: usize) -> Result<()> {
        match node {
            Node::Element {
                tag,
                attributes,
                children,
                ..
            } => {
                let entity_name = format!("entity_{}", index);

                // Create entity
                self.emit_line(&format!("let {} = world.spawn_empty().id();", entity_name))?;

                // Add transform component
                let x = self.find_attr_value(attributes, "x").unwrap_or("0.0".to_string());
                let y = self.find_attr_value(attributes, "y").unwrap_or("0.0".to_string());
                self.emit_line(&format!(
                    "world.entity_mut({}).insert(Transform::from_xy({}, {}));",
                    entity_name, x, y
                ))?;

                // Add shape component
                match tag {
                    ElementTag::Circle => {
                        let radius = self.find_attr_value(attributes, "radius").unwrap_or("10.0".to_string());
                        self.emit_line(&format!(
                            "world.entity_mut({}).insert(Shape::Circle {{ radius: {} }});",
                            entity_name, radius
                        ))?;
                    }
                    ElementTag::Rectangle => {
                        let width = self.find_attr_value(attributes, "width").unwrap_or("100.0".to_string());
                        let height = self.find_attr_value(attributes, "height").unwrap_or("100.0".to_string());
                        self.emit_line(&format!(
                            "world.entity_mut({}).insert(Shape::Rectangle {{ width: {}, height: {} }});",
                            entity_name, width, height
                        ))?;
                    }
                    ElementTag::Text => {
                        let content = self.find_attr_value(attributes, "content").unwrap_or("\"\"".to_string());
                        self.emit_line(&format!(
                            "world.entity_mut({}).insert(TextContent {{ text: {}.to_string(), ..Default::default() }});",
                            entity_name, content
                        ))?;
                    }
                    _ => {}
                }

                // Add style component
                let fill = self.find_attr_value(attributes, "fill");
                let stroke = self.find_attr_value(attributes, "stroke");
                if fill.is_some() || stroke.is_some() {
                    let fill_str = fill.map(|f| format!("Some(Color::parse({}))", f))
                        .unwrap_or_else(|| "None".to_string());
                    let stroke_str = stroke.map(|s| format!("Some(Color::parse({}))", s))
                        .unwrap_or_else(|| "None".to_string());
                    self.emit_line(&format!(
                        "world.entity_mut({}).insert(Style {{ fill: {}, stroke: {}, ..Default::default() }});",
                        entity_name, fill_str, stroke_str
                    ))?;
                }

                writeln!(self.output)?;

                // Process children
                for (i, child) in children.iter().enumerate() {
                    self.emit_node(child, index * 100 + i)?;
                }
            }
            Node::Expression { expr } => {
                let expr_str = self.expr_to_rust(expr);
                self.emit_line(&format!("// Expression: {}", expr_str))?;
            }
            _ => {}
        }

        Ok(())
    }

    fn emit_new_fn(&mut self, _component: &Component, struct_name: &str) -> Result<()> {
        writeln!(self.output, "impl {} {{", struct_name)?;
        self.indent += 1;

        self.emit_line("/// Create a new component instance")?;
        self.emit_line("pub fn new(ctx: &mut Context) -> Self {")?;
        self.indent += 1;
        self.emit_line("Self::create(ctx)")?;
        self.indent -= 1;
        self.emit_line("}")?;

        self.indent -= 1;
        writeln!(self.output, "}}")?;
        Ok(())
    }

    fn emit_wasm_entry_point(&mut self, _component: &Component, struct_name: &str) -> Result<()> {
        writeln!(self.output)?;
        self.emit_line("/// WASM Entry Point")?;
        self.emit_line("#[wasm_bindgen(start)]")?;
        self.emit_line("pub fn start() -> Result<(), JsValue> {")?;
        self.indent += 1;
        
        self.emit_line("console_error_panic_hook::set_once();")?;
        self.emit_line("tracing_wasm::set_as_global_default();")?;
        writeln!(self.output)?;

        self.emit_line("let mut app = omnicraft_runtime::App::new();")?;
        self.emit_line("let mut ctx = Context::new();")?;
        self.emit_line(&format!("let component = {}::new(&mut ctx);", struct_name))?;
        self.emit_line("component.mount(app.world_mut());")?;
        writeln!(self.output)?;

        // Run the schedule (for any systems)
        self.emit_line("app.tick();")?;
        writeln!(self.output)?;

        // Render to canvas
        self.emit_line("// Render to canvas")?;
        self.emit_line("let mut queue = RenderQueue::new();")?;
        self.emit_line("Renderer::render(app.world_mut(), &mut queue);")?;
        writeln!(self.output)?;
        self.emit_line("let renderer = omnicraft_runtime::render::wasm::CanvasRenderer::new(\"canvas\")?;")?;
        self.emit_line("renderer.execute(&queue.commands);")?;
        writeln!(self.output)?;
        
        self.emit_line("Ok(())")?;
        
        self.indent -= 1;
        self.emit_line("}")?;

        Ok(())
    }

    // ========================================================================
    // Helper Methods
    // ========================================================================

    fn emit_line(&mut self, line: &str) -> Result<()> {
        let indent = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line)?;
        Ok(())
    }

    fn expr_to_rust(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(Literal::Number(n)) => {
                if n.fract() == 0.0 {
                    format!("{:.1}", n)
                } else {
                    format!("{}", n)
                }
            }
            Expression::Literal(Literal::String(s)) => format!("\"{}\"", s),
            Expression::Literal(Literal::Boolean(b)) => format!("{}", b),
            Expression::Literal(Literal::Null) => "None".to_string(),
            Expression::Identifier(name) => name.clone(),
            Expression::Binary { left, op, right } => {
                let l = self.expr_to_rust(left);
                let r = self.expr_to_rust(right);
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Eq => "==",
                    BinaryOp::Ne => "!=",
                    BinaryOp::Lt => "<",
                    BinaryOp::Gt => ">",
                    BinaryOp::Le => "<=",
                    BinaryOp::Ge => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                };
                format!("({} {} {})", l, op_str, r)
            }
            Expression::Unary { op, operand } => {
                let inner = self.expr_to_rust(operand);
                match op {
                    UnaryOp::Neg => format!("-{}", inner),
                    UnaryOp::Not => format!("!{}", inner),
                }
            }
            Expression::Call { callee, args } => {
                let callee_str = self.expr_to_rust(callee);
                let args_str: Vec<String> = args.iter().map(|a| self.expr_to_rust(a)).collect();
                format!("{}({})", callee_str, args_str.join(", "))
            }
            Expression::Member { object, property, .. } => {
                let obj = self.expr_to_rust(object);
                format!("{}.{}", obj, property)
            }
            Expression::Index { object, index } => {
                let obj = self.expr_to_rust(object);
                let idx = self.expr_to_rust(index);
                format!("{}[{}]", obj, idx)
            }
            Expression::Arrow { params, body } => {
                let params_str: Vec<String> = params.iter().map(|p| p.name.clone()).collect();
                let body_str = match body {
                    ArrowBody::Expression(e) => self.expr_to_rust(e),
                    ArrowBody::Block(_) => "{ /* block */ }".to_string(),
                };
                if params_str.is_empty() {
                    format!("|| {}", body_str)
                } else {
                    format!("|{}| {}", params_str.join(", "), body_str)
                }
            }
            Expression::Ternary { condition, then_expr, else_expr } => {
                let cond = self.expr_to_rust(condition);
                let then_str = self.expr_to_rust(then_expr);
                let else_str = self.expr_to_rust(else_expr);
                format!("if {} {{ {} }} else {{ {} }}", cond, then_str, else_str)
            }
            Expression::Template { parts } => {
                let mut result = String::from("format!(\"");
                let mut args = Vec::new();
                for part in parts {
                    match part {
                        TemplatePart::String(s) => result.push_str(s),
                        TemplatePart::Expression(e) => {
                            result.push_str("{}");
                            args.push(self.expr_to_rust(e));
                        }
                    }
                }
                result.push('"');
                if !args.is_empty() {
                    result.push_str(", ");
                    result.push_str(&args.join(", "));
                }
                result.push(')');
                result
            }
            Expression::Array(elements) => {
                let elems: Vec<String> = elements.iter().map(|e| self.expr_to_rust(e)).collect();
                format!("vec![{}]", elems.join(", "))
            }
            Expression::Object(props) => {
                // For now, generate a HashMap
                let pairs: Vec<String> = props.iter()
                    .map(|(k, v)| format!("(\"{}\".to_string(), {})", k, self.expr_to_rust(v)))
                    .collect();
                format!("HashMap::from([{}])", pairs.join(", "))
            }
        }
    }

    fn find_attr_value(&self, attributes: &[Attribute], name: &str) -> Option<String> {
        attributes.iter().find(|a| a.name == name).map(|a| {
            match &a.value {
                AttributeValue::Static(lit) => match lit {
                    Literal::Number(n) => {
                        if n.fract() == 0.0 {
                            format!("{:.1}", n)
                        } else {
                            format!("{}", n)
                        }
                    }
                    Literal::String(s) => format!("\"{}\"", s),
                    Literal::Boolean(b) => format!("{}", b),
                    Literal::Null => "None".to_string(),
                },
                AttributeValue::Dynamic(expr) => self.expr_to_rust(expr),
                AttributeValue::Spread(_) => "/* spread */".to_string(),
                AttributeValue::Boolean(b) => format!("{}", b),
            }
        })
    }

    fn infer_type(&self, expr: Option<&Expression>) -> String {
        match expr {
            Some(Expression::Call { callee, args, .. }) => {
                if let Expression::Identifier(name) = callee.as_ref() {
                    if name == "signal" || name == "memo" {
                        if let Some(first_arg) = args.first() {
                            return self.infer_expr_type(first_arg);
                        }
                    }
                }
                "Any".to_string()
            }
            Some(expr) => self.infer_expr_type(expr),
            None => "Any".to_string(),
        }
    }

    fn infer_expr_type(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(Literal::Number(_)) => "f64".to_string(),
            Expression::Literal(Literal::String(_)) => "String".to_string(),
            Expression::Literal(Literal::Boolean(_)) => "bool".to_string(),
            Expression::Array(_) => "Vec<Any>".to_string(),
            Expression::Arrow { .. } => "Fn()".to_string(),
            _ => "Any".to_string(),
        }
    }

    fn to_pascal_case(&self, s: &str) -> String {
        s.split(|c: char| c == '_' || c == '-' || c == ' ')
            .filter(|part| !part.is_empty())
            .map(|part| {
                let mut chars = part.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect()
    }
}

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}
