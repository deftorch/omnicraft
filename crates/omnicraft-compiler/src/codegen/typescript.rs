//! TypeScript Code Generator
//!
//! Generates TypeScript definitions (.d.ts) for OmniCraft components.

use crate::ast::*;
use anyhow::Result;
use std::fmt::Write;

/// Code generator that produces TypeScript definition code
pub struct TypeScriptGenerator {
    output: String,
    indent: usize,
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
        }
    }

    /// Generate TypeScript definition (`.d.ts`) for a component
    pub fn generate(&mut self, component: &Component) -> Result<String> {
        self.output.clear();

        // Header
        self.emit_header(component)?;

        // Interface for Props (future proofing, mostly for attributes/signals exposed)
        self.emit_props_interface(component)?;

        // Component Class definition
        self.emit_component_class(component)?;

        Ok(self.output.clone())
    }

    fn emit_header(&mut self, component: &Component) -> Result<()> {
        writeln!(self.output, "// Generated by OmniCraft Compiler")?;
        writeln!(self.output, "// Source: {}", component.metadata.file_path)?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_props_interface(&mut self, component: &Component) -> Result<()> {
        let name = &component.name;
        writeln!(self.output, "export interface {}Props {{", name)?;
        
        // TODO: In future, we would analyze props here.
        // For now, assume no explicit props until we implement props in AST.
        
        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_component_class(&mut self, component: &Component) -> Result<()> {
        let name = &component.name;
        
        writeln!(self.output, "/**")?;
        writeln!(self.output, " * {} Component", name)?;
        writeln!(self.output, " */")?;
        writeln!(self.output, "export declare class {} {{", name)?;
        self.indent += 1;

        // Constructor
        self.emit_line(&format!("constructor(props?: {}Props);", name))?;
        writeln!(self.output)?;

        // Expose signals as public readonly properties/getters?
        // Or specific methods.
        self.emit_signals(component)?;

        // Mount method
        self.emit_line("mount(target: HTMLElement): void;")?;

        self.indent -= 1;
        writeln!(self.output, "}}")?;
        Ok(())
    }

    fn emit_signals(&mut self, component: &Component) -> Result<()> {
        if let Some(script) = &component.script {
            for stmt in &script.statements {
                if let Statement::VariableDeclaration {
                    name,
                    reactive,
                    init,
                    ..
                } = stmt
                {
                    if *reactive != ReactiveKind::None {
                        let ty = self.infer_ts_type(init.as_ref());
                        self.emit_line(&format!("readonly {}: Signal<{}>;", name, ty))?;
                    }
                }
            }
        }
        Ok(())
    }

    fn infer_ts_type(&self, expr: Option<&Expression>) -> String {
        match expr {
            Some(Expression::Call { callee, args, .. }) => {
                if let Expression::Identifier(name) = callee.as_ref() {
                    if name == "signal" || name == "memo" {
                        if let Some(first_arg) = args.first() {
                            return self.infer_expr_ts_type(first_arg);
                        }
                    }
                }
                "any".to_string()
            }
            Some(expr) => self.infer_expr_ts_type(expr),
            None => "any".to_string(),
        }
    }

    fn infer_expr_ts_type(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(Literal::Number(_)) => "number".to_string(),
            Expression::Literal(Literal::String(_)) => "string".to_string(),
            Expression::Literal(Literal::Boolean(_)) => "boolean".to_string(),
            Expression::Array(_) => "any[]".to_string(),
            Expression::Arrow { .. } => "() => void".to_string(),
            _ => "any".to_string(),
        }
    }

    fn emit_line(&mut self, line: &str) -> Result<()> {
        let indent = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line)?;
        Ok(())
    }
}

// Minimal Signal type definition
// users would likely import this from the runtime lib
// but for d.ts generation we might presume it exists globally or imports it.
